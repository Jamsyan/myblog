# 性能优化

## 1. 前端性能优化

### 1.1 代码分割与懒加载

#### 路由懒加载

```javascript
// 使用动态导入实现路由懒加载
const routes = [
  {
    path: '/profile',
    component: () => import('@/modules/profile/ProfilePage.vue')
  },
  {
    path: '/settings',
    component: () => import('@/modules/settings/SettingsPage.vue')
  }
];
```

#### 组件懒加载

```vue
<template>
  <div>
    <AsyncComponent v-if="showComponent" />
  </div>
</template>

<script setup>
import { defineAsyncComponent } from 'vue';

const AsyncComponent = defineAsyncComponent(() =>
  import('./HeavyComponent.vue')
);
</script>
```

### 1.2 图片优化

#### 图片懒加载

```vue
<template>
  <img 
    v-lazy="imageUrl" 
    :alt="imageAlt"
    loading="lazy"
    @load="onImageLoad"
  />
</template>

<script setup>
import { useLazyload } from '@vueuse/core';

const { imageUrl, imageAlt } = defineProps(['imageUrl', 'imageAlt']);

const onImageLoad = () => {
  console.log('图片加载完成');
};
</script>
```

#### 图片格式选择

- **WebP**：比JPEG小25-35%，比PNG小26%
- **AVIF**：比WebP再小20%
- **响应式图片**：根据设备尺寸加载合适大小的图片

### 1.3 列表优化

#### 虚拟滚动

```vue
<template>
  <VirtualList
    :items="largeList"
    :item-height="50"
    :visible-items="20"
    v-slot="{ item }"
  >
    <div class="list-item">{{ item.name }}</div>
  </VirtualList>
</template>
```

#### 分页加载

```javascript
const loadData = async (page = 1) => {
  const response = await api.getPosts({
    page,
    pageSize: 20
  });
  
  posts.value = [...posts.value, ...response.data];
  hasMore.value = response.hasMore;
};

const loadMore = () => {
  if (hasMore.value && !loading.value) {
    loadData(currentPage.value + 1);
  }
};
```

### 1.4 Canvas动画优化

#### 性能监控

```javascript
import { PerformanceMonitor } from '@/utils/animationPerformance';

const monitor = new PerformanceMonitor();

monitor.start();

// 动画完成后
monitor.stop();

console.log('动画性能:', {
  fps: monitor.getAverageFPS(),
  frameTime: monitor.getAverageFrameTime(),
  droppedFrames: monitor.getDroppedFrames()
});
```

#### 动态参数调整

```javascript
const adjustAnimationParams = (performanceLevel) => {
  const params = {
    high: {
      particleCount: 100,
      animationSpeed: 1.5,
      quality: 'high'
    },
    medium: {
      particleCount: 60,
      animationSpeed: 1.0,
      quality: 'medium'
    },
    low: {
      particleCount: 30,
      animationSpeed: 0.5,
      quality: 'low'
    }
  };
  
  return params[performanceLevel] || params.medium;
};
```

#### 离屏Canvas缓存

```javascript
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d');

// 预渲染静态元素
function preRenderStaticElements() {
  offscreenCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
  offscreenCtx.fillRect(0, 0, width, height);
}

// 在主Canvas中绘制缓存
function render() {
  ctx.drawImage(offscreenCanvas, 0, 0);
}
```

### 1.5 状态管理优化

#### 避免不必要的响应式

```javascript
// ❌ 不好的做法：将所有数据都设为响应式
const state = reactive({
  staticConfig: { /* 静态配置 */ },
  dynamicData: { /* 动态数据 */ }
});

// ✅ 好的做法：只将需要响应的数据设为响应式
const staticConfig = { /* 静态配置 */ };
const dynamicData = reactive({ /* 动态数据 */ });
```

#### 计算属性缓存

```javascript
// 计算属性会自动缓存
const filteredList = computed(() => {
  return list.value.filter(item => item.active);
});

// 避免在模板中直接使用复杂表达式
```

### 1.6 网络请求优化

#### 请求防抖

```javascript
import { debounce } from 'lodash-es';

const searchPosts = debounce(async (keyword) => {
  const results = await api.searchPosts(keyword);
  searchResults.value = results;
}, 300);
```

#### 请求节流

```javascript
import { throttle } from 'lodash-es';

const handleScroll = throttle(() => {
  if (shouldLoadMore()) {
    loadMorePosts();
  }
}, 200);
```

#### 请求合并

```javascript
class RequestBatcher {
  constructor(batchSize = 5, delay = 100) {
    this.batch = [];
    this.batchSize = batchSize;
    this.delay = delay;
    this.timer = null;
  }
  
  add(request) {
    this.batch.push(request);
    
    if (this.batch.length >= this.batchSize) {
      this.flush();
    } else {
      this.scheduleFlush();
    }
  }
  
  scheduleFlush() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => this.flush(), this.delay);
  }
  
  async flush() {
    const requests = [...this.batch];
    this.batch = [];
    this.timer = null;
    
    const responses = await Promise.all(requests);
    return responses;
  }
}
```

## 2. 后端性能优化

### 2.1 数据库优化

#### 索引优化

```python
# 为常用查询字段添加索引
class Post(Base):
    __tablename__ = 'posts'
    
    id = Column(Integer, primary_key=True)
    title = Column(String(200), index=True)  # 添加索引
    author_id = Column(Integer, ForeignKey('users.id'), index=True)
    created_at = Column(DateTime, index=True)
    status = Column(String(20), index=True)
```

#### 查询优化

```python
# ❌ 不好的做法：N+1查询问题
posts = db.query(Post).all()
for post in posts:
    comments = db.query(Comment).filter_by(post_id=post.id).all()
    post.comments = comments

# ✅ 好的做法：使用eager loading
posts = db.query(Post).options(
    joinedload(Post.comments)
).all()
```

#### 批量操作

```python
# 批量插入
def bulk_insert_posts(posts_data):
    db.bulk_insert_mappings(Post, posts_data)
    db.commit()

# 批量更新
def bulk_update_posts(updates):
    db.bulk_update_mappings(Post, updates)
    db.commit()
```

### 2.2 API响应优化

#### 响应压缩

```python
from fastapi.middleware.gzip import GZipMiddleware

app.add_middleware(GZipMiddleware, minimum_size=1000)
```

#### 响应缓存

```python
from fastapi_cache import FastAPICache
from fastapi_cache.backends import InMemoryCache

cache = FastAPICache(backend=InMemoryCache())

@app.get("/api/posts")
@cache(expire=60)  # 缓存60秒
async def get_posts():
    return {"posts": get_posts_from_db()}
```

#### 分页响应

```python
from fastapi import Query

@app.get("/api/posts")
async def get_posts(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100)
):
    skip = (page - 1) * page_size
    posts = db.query(Post).offset(skip).limit(page_size).all()
    
    return {
        "data": posts,
        "page": page,
        "page_size": page_size,
        "total": db.query(Post).count()
    }
```

### 2.3 服务通信优化

#### 连接池

```python
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=10,
    max_overflow=20,
    pool_timeout=30
)
```

#### 异步处理

```python
import asyncio

@app.post("/api/posts")
async def create_post(post_data: PostCreate):
    # 异步处理耗时操作
    result = await process_post_async(post_data)
    return result

async def process_post_async(post_data):
    # 模拟耗时操作
    await asyncio.sleep(1)
    return {"status": "created", "data": post_data}
```

## 3. 构建优化

### 3.1 前端构建优化

#### Vite配置优化

```javascript
// vite.config.js
export default defineConfig({
  build: {
    // 代码分割
    rollupOptions: {
      output: {
        manualChunks: {
          'vue-vendor': ['vue', 'vue-router'],
          'utils': ['lodash-es', 'axios']
        }
      }
    },
    
    // 压缩配置
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    
    // 资源内联限制
    assetsInlineLimit: 4096
  },
  
  // 依赖预构建
  optimizeDeps: {
    include: ['vue', 'vue-router', 'axios']
  }
});
```

#### Tree Shaking

```javascript
// 使用ES模块导入，支持Tree Shaking
import { debounce } from 'lodash-es';  // ✅ 好的做法
import _ from 'lodash';                  // ❌ 不好的做法
```

### 3.2 后端构建优化

#### 依赖优化

```toml
# pyproject.toml
[project]
dependencies = [
    "fastapi>=0.100.0",
    "uvicorn>=0.20.0",
    # 只安装必要的依赖
]

[tool.uv]
dev-dependencies = [
    "pytest>=7.0.0",
    "black>=23.0.0",
    # 开发依赖
]
```

## 4. 监控与调优

### 4.1 性能监控

#### 前端性能监控

```javascript
// 使用Performance API
const measurePerformance = (name, fn) => {
  const start = performance.now();
  const result = fn();
  const end = performance.now();
  
  console.log(`${name} 耗时: ${(end - start).toFixed(2)}ms`);
  
  return result;
};

// 使用示例
measurePerformance('数据加载', () => {
  return loadData();
});
```

#### 后端性能监控

```python
import time
from functools import wraps

def measure_time(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        result = await func(*args, **kwargs)
        end_time = time.time()
        
        logger.info(f"{func.__name__} 耗时: {(end_time - start_time) * 1000:.2f}ms")
        
        return result
    return wrapper

# 使用示例
@app.get("/api/posts")
@measure_time
async def get_posts():
    return {"posts": get_posts_from_db()}
```

### 4.2 性能指标

#### 前端性能指标

- **First Contentful Paint (FCP)**：首次内容绘制时间 < 1.8s
- **Largest Contentful Paint (LCP)**：最大内容绘制时间 < 2.5s
- **First Input Delay (FID)**：首次输入延迟 < 100ms
- **Cumulative Layout Shift (CLS)**：累积布局偏移 < 0.1

#### 后端性能指标

- **响应时间**：P50 < 200ms, P95 < 500ms, P99 < 1000ms
- **吞吐量**：每秒处理请求数 > 1000 req/s
- **错误率**：< 0.1%
- **CPU使用率**：< 70%
- **内存使用率**：< 80%

## 5. 性能优化检查清单

### 前端检查清单

- [ ] 实现了路由懒加载
- [ ] 实现了组件懒加载
- [ ] 图片使用了懒加载
- [ ] 使用了虚拟滚动处理长列表
- [ ] 实现了请求防抖和节流
- [ ] 避免了不必要的响应式数据
- [ ] 使用了计算属性缓存
- [ ] 实现了代码分割
- [ ] 配置了Tree Shaking
- [ ] 优化了打包体积

### 后端检查清单

- [ ] 为常用查询字段添加了索引
- [ ] 优化了数据库查询
- [ ] 使用了批量操作
- [ ] 实现了响应压缩
- [ ] 实现了响应缓存
- [ ] 实现了分页查询
- [ ] 配置了连接池
- [ ] 使用了异步处理
- [ ] 实现了性能监控
- [ ] 优化了依赖管理

---

**文档版本**：v1.0.0  
**最后更新**：2026-01-29  
**维护者**：MyBlog开发团队