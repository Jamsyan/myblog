# 代码审查规范

## 1. 审查流程

### 1.1 审查准备
- 阅读相关代码文件
- 理解业务需求和上下文
- 准备审查清单

### 1.2 审查执行
- 逐行检查代码
- 标记问题代码
- 记录问题类型和严重程度

### 1.3 审查结果整理
- 汇总审查发现的问题
- 按严重程度分类
- 生成审查报告

## 2. 审查要点

### 2.1 代码质量标准

#### 2.1.1 嵌套层级
- **限制**：方法嵌套层级最多 3 层，循环嵌套层级最多 2 层
- **检查方法**：统计每个方法的嵌套深度
- **违规示例**：
  ```python
  def bad_example():
      if condition1:
          if condition2:
              if condition3:
                  if condition4:
                      # 4层嵌套，违反规范
                      return result
  ```
- **正确示例**：
  ```python
  def good_example():
      if not condition1:
          return early_result
      
      if not condition2:
          return early_result
      
      if not condition3:
          return early_result
      
      if not condition4:
          return early_result
  ```

#### 2.1.2 方法长度
- **限制**：单个方法不超过 50 行
- **检查方法**：统计每个方法的行数
- **违规示例**：
  ```python
  def bad_method():
      # 超过100行，难以理解和维护
      # ... 大量代码 ...
      # ... 更多代码 ...
      # ... 继续更多代码 ...
  ```
- **正确示例**：
  ```python
  def good_method():
      # 清晰的职责分离
      result = self._validate_input()
      if not result:
          return self._build_error_response()
      
      data = self._process_data(result)
      return self._build_success_response(data)
  ```

#### 2.1.3 代码复杂度
- **圈复杂度限制**：认知复杂度不超过 10
- **检查方法**：使用工具或人工评估
- **违规示例**：
  ```python
  def complex_method():
      # 过多职责，难以理解
      if condition1:
          if condition2:
              if condition3:
                  if condition4:
                      # 复杂度过高
                      return result
      # ... 更多嵌套 ...
  ```

#### 2.1.4 守护判断
- **要求**：使用平行等级的 if 判断，早暴露早解决问题
- **检查方法**：检查是否使用了深层嵌套而非提前返回
- **违规示例**：
  ```python
  def bad_example():
      if condition1:
          if condition2:
              if condition3:
                  # 深层嵌套，未使用守护判断
                  return result
  ```
- **正确示例**：
  ```python
  def good_example():
      if not condition1:
          return early_result
      
      if not condition2:
          return early_result
      
      if not condition3:
          return early_result
  ```

#### 2.1.5 异常处理
- **要求**：清晰的异常处理，避免吞掉异常
- **检查方法**：检查异常是否被正确捕获和处理
- **违规示例**：
  ```python
  def bad_exception():
      try:
          result = self._process()
          # 吞掉异常，无法追踪问题
          return result
      except:
          pass  # 异常被忽略
  ```
- **正确示例**：
  ```python
  def good_exception():
      try:
          result = self._process()
          return result
      except ValueError as e:
          self.logger.error(f"处理失败: {str(e)}")
          return self._build_error_response(str(e))
      except Exception as e:
          self.logger.error(f"未知错误: {str(e)}")
          return self._build_error_response("未知错误")
  ```

#### 2.1.6 文档字符串
- **要求**：所有公共方法必须有文档字符串
- **检查方法**：检查是否有 Google 风格文档字符串
- **违规示例**：
  ```python
  def no_doc():
      # 缺少文档字符串
      def process(self, data):
          return result
  ```
- **正确示例**：
  ```python
  def with_doc():
      """
      处理数据
      
      Args:
          data: 输入数据
          
      Returns:
          Dict[str, Any]: 处理结果
      """
      def process(self, data):
          return result
  ```

#### 2.1.7 单一职责原则
- **要求**：每个方法只做一件事
- **检查方法**：检查方法是否承担多个职责
- **违规示例**：
  ```python
  def multi_responsibility():
      # 验证输入、处理数据、构建响应、记录日志、发送通知
      # 一个方法做了太多事情
      return result
  ```
- **正确示例**：
  ```python
  def single_responsibility():
      # 只负责验证输入
      def validate_input(self, data):
          return self._validator.validate(data)
      
      # 处理数据由其他方法负责
      def process_data(self, data):
          return self._processor.process(data)
  ```

## 3. 反模式（Anti-Patterns）

### 3.1 必须避免的反模式

#### 3.1.1 深层嵌套
- ❌ **问题**：超过 3 层的嵌套
- ✅ **解决**：使用守护判断，提前返回
- **示例**：
  ```python
  # 反模式
  if condition1:
      if condition2:
          if condition3:
              if condition4:
                  # 深层嵌套
                  return result
  ```
  
  # 正确模式
  if not condition1:
      return early_result
  
  if not condition2:
      return early_result
  
  if not condition3:
      return early_result
  ```

#### 3.1.2 过长方法
- ❌ **问题**：超过 50 行的方法
- ✅ **解决**：拆分为多个小方法
- **示例**：
  ```python
  # 反模式：过长的方法
  def long_method():
      # 100+ 行代码
      # ... 大量代码 ...
      return result
  
  # 正确模式：拆分方法
  def short_method1():
      # 验证输入
      if not self._validate_input(data):
          return self._build_error_response()
      
  def short_method2():
      # 处理数据
      return self._process_data(data)
  ```

#### 3.1.3 重复代码
- ❌ **问题**：相同逻辑重复出现
- ✅ **解决**：提取公共方法
- **示例**：
  ```python
  # 反模式：重复代码
  def service_a():
      if condition1:
          return result1
  
  def service_b():
      if condition1:
          return result1
  
  def service_c():
      if condition1:
          return result1
  ```
  
  # 正确模式：提取公共方法
  def common_validation():
      if not self._validate_input(data):
          return self._build_error_response()
  
  def common_processing():
      return self._process_data(data)
  
  def service_a():
      if not self._validate_input(data):
          return common_validation()
      return common_processing()
  
  def service_b():
      if not self._validate_input(data):
          return common_validation()
      return common_processing()
  
  def service_c():
      if not self._validate_input(data):
          return common_validation()
      return common_processing()
  ```

#### 3.1.4 职责不单一
- ❌ **问题**：一个方法做多件事
- ✅ **解决**：拆分为多个职责单一的方法
- **示例**：
  ```python
  # 反模式：多职责
  def multi_duty():
      # 验证、处理、记录、通知
      return result
  
  # 正确模式：单一职责
  def validate_only():
      if not self._validator.validate(data):
          return self._build_error_response()
  
  def process_only():
      return self._processor.process(data)
  
  def notify_only():
      self._notifier.send_notification(result)
  ```

#### 3.1.5 异常处理不当
- ❌ **问题**：吞掉异常或使用裸 except
- ✅ **解决**：明确捕获和处理异常
- **示例**：
  ```python
  # 反模式：异常处理不当
  def bad_exception():
      try:
          result = self._process()
          return result
      except:
          pass  # 吞掉异常
  
  # 正确模式：明确异常处理
  def good_exception():
      try:
          result = self._process()
          return result
      except ValueError as e:
          self.logger.error(f"验证失败: {str(e)}")
          return self._build_error_response("验证失败")
      except Exception as e:
          self.logger.error(f"处理失败: {str(e)}")
          return self._build_error_response("处理失败")
  ```

## 4. 审查工具

### 4.1 自动化审查
- 使用 pylint 进行静态代码分析
- 使用 mypy 进行类型检查
- 使用 black 进行代码格式化
- 使用 isort 进行导入排序

### 4.2 手动审查清单
- [ ] 嵌套层级是否超过 3 层
- [ ] 方法长度是否超过 50 行
- [ ] 是否使用了守护判断而非深层嵌套
- [ ] 异常处理是否清晰
- [ ] 是否有必要的文档字符串
- [ ] 是否遵循单一职责原则
- [ ] 是否有重复代码
- [ ] 变量命名是否有意义
- [ ] 是否使用了类型注解
- [ ] 是否有单元测试覆盖

## 5. 审查报告

### 5.1 问题统计
- 按严重程度分类：严重、高、中、低
- 每个问题包含：文件路径、行号、问题描述、建议修复方案

### 5.2 改进建议
- 短期改进：立即修复严重问题
- 中期改进：重构高优先级问题
- 长期改进：建立代码质量监控体系

## 6. 最佳实践

### 6.1 代码编写原则
- **KISS 原则**：Keep It Simple, Stupid
- **DRY 原则**：Don't Repeat Yourself
- **YAGNI 原则**：You Aren't Gonna Need It
- **单一职责**：每个方法只做一件事
- **开闭原则**：对扩展开放，对修改封闭
- **依赖倒置**：依赖抽象而非具体实现

### 6.2 重构技巧
- **小步重构**：每次只改一小部分，确保功能正常
- **测试驱动**：重构前后都要运行测试
- **代码审查**：重构后进行代码审查
- **持续改进**：定期回顾和改进代码质量

## 7. 参考资源
- PEP 8 编码规范
- Google Python 风格指南
- Clean Code 原则
- Refactoring Guru