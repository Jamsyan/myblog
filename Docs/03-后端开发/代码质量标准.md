# 代码质量标准

## 1. 代码复杂度

### 1.1 圈复杂度（Cyclomatic Complexity）
- **定义**：衡量程序逻辑复杂度的指标
- **计算方法**：每个决策点（if、while、for、except）+ 1
- **标准**：认知复杂度不超过 10
- **示例**：
  ```python
  # 复杂度过高（CC = 15）
  def high_complexity(data):
      if data:
          if condition1:
              if condition2:
                  if condition3:
                      if condition4:
                          if condition5:
                              # 5个if，CC = 6
                              return result
  
  # 复杂度适中（CC = 5）
  def medium_complexity(data):
      if not data:
          return default
      
      if condition1:
          return result1
      
      if condition2:
          return result2
  
  # 复杂度低（CC = 2）
  def low_complexity(data):
      if not data:
          return default
      
      if condition1:
          return result1
      
      return result2
  ```

### 1.2 认知复杂度（Cognitive Complexity）
- **定义**：衡量代码理解难度的指标
- **计算方法**：嵌套层级 + 分支数量
- **标准**：认知复杂度不超过 15
- **示例**：
  ```python
  # 认知复杂度过高
  def high_cognitive(data):
      if condition1:
          if condition2:
              if condition3:
                  # 3层嵌套，认知复杂度高
                  return result
  
  # 认知复杂度适中
  def medium_cognitive(data):
      if not condition1:
          return result1
      
      if not condition2:
          return result2
  
  # 认知复杂度低
  def low_cognitive(data):
      if not condition1:
          return result1
      
      if not condition2:
          return result2
  ```

## 2. 代码异味（Code Smells）

### 2.1 重复代码（Duplicated Code）
- **定义**：相同或相似的代码在多处出现
- **影响**：增加维护成本，容易导致不一致
- **检测方法**：
  - 代码审查时手动识别
  - 使用工具：pylint、flake8
- **解决方案**：
  - 提取公共方法
  - 使用函数式编程
  - 使用模板方法

### 2.2 过长的方法（Long Method）
- **定义**：单个方法超过 50 行
- **影响**：难以理解、难以测试、违反单一职责原则
- **检测方法**：
  - 统计方法行数
  - 使用工具：radon、vulture
- **解决方案**：
  - 拆分为多个小方法
  - 使用策略模式
  - 提取子方法

### 2.3 过长参数列表（Long Parameter List）
- **定义**：方法参数超过 5 个
- **影响**：难以理解和使用
- **解决方案**：
  - 使用配置对象
  - 使用 **kwargs
  - 创建参数类

### 2.4 过度嵌套（Deep Nesting）
- **定义**：嵌套层级超过 3 层
- **影响**：可读性极差，难以维护
- **检测方法**：
  - 统计嵌套层级
  - 使用工具：pylint
- **解决方案**：
  - 使用守护判断（提前返回）
  - 提取子方法
  - 使用策略模式

### 2.5 临时变量（Temporary Field）
- **定义**：在类中定义临时字段
- **影响**：代码不清晰，容易出错
- **解决方案**：
  - 使用局部变量
  - 重构为方法参数
  - 使用命名元组

### 2.6 注释掉代码（Commented Code）
- **定义**：被注释掉的代码未删除
- **影响**：代码混乱，容易误导
- **解决方案**：
  - 删除不需要的代码
  - 使用版本控制（git）管理历史

### 2.7 魔法数字（Magic Numbers）
- **定义**：代码中直接出现的数字，没有明确含义
- **影响**：难以理解，难以维护
- **解决方案**：
  - 定义为常量
  - 使用枚举
  - 添加注释说明

### 2.8 过度耦合（Tight Coupling）
- **定义**：模块之间依赖关系过于紧密
- **影响**：难以测试，难以修改
- **解决方案**：
  - 使用依赖注入
  - 定义接口
  - 使用事件驱动架构

### 2.9 全局变量（Global Variables）
- **定义**：在模块级别定义全局变量
- **影响**：难以追踪状态，容易出错
- **解决方案**：
  - 使用类属性
  - 使用配置对象
  - 使用依赖注入

## 3. 代码可读性

### 3.1 命名规范
- **类名**：大驼峰（PascalCase）
  ```python
  class UserService:  # 正确
  class user_service:  # 错误
  ```
  
- **方法/函数名**：小驼峰（camelCase）
  ```python
  def get_user_data():  # 正确
  def GetUser_Data():  # 错误
  ```
  
- **常量**：全大写下划线（UPPER_SNAKE_CASE）
  ```python
  MAX_RETRY_COUNT = 3  # 正确
  max_retry_count = 3  # 错误
  ```
  
- **私有方法/属性**：单下划线前缀（_private_method）
  ```python
  def _validate_input():  # 正确
  def validate_input():  # 错误
  ```

### 3.2 代码结构
- **文件组织**：
  - 相关功能放在同一模块
  - 按功能分层（controller、service、repository）
  - 避免循环依赖
  
- **导入顺序**：
  - 标准库 → 第三方库 → 本地模块
  - 按字母顺序排列
  - 避免循环导入

### 3.3 注释和文档
- **文档字符串**：
  - 所有公共方法必须有 Google 风格文档字符串
  - 包含：Args、Returns、Raises、Examples
  ```python
  def process_data(data: Dict[str, Any]) -> Dict[str, Any]:
      """
      处理数据
      
      Args:
          data: 输入数据字典
          
      Returns:
          Dict[str, Any]: 处理结果
          
      Raises:
          ValueError: 当数据格式不正确时
          
      Examples:
          >>> process_data({"key": "value"})
          {"status": "success", "data": {...}}
      """
      # 方法实现
  ```
  
- **注释原则**：
  - 不要注释显而易见的代码
  - 注释"为什么"而非"是什么"
  - 注释与代码同步更新
  - 使用 TODO 标记待办事项

## 4. 代码可维护性

### 4.1 单一职责原则（Single Responsibility Principle）
- **定义**：每个类和方法只做一件事
- **检查方法**：
  - 方法名是否清晰表达职责
  - 方法是否只改变一个状态
  - 方法是否只依赖一个抽象层
- **示例**：
  ```python
  # 违反单一职责
  def process_and_save_and_notify(data):
      # 验证、处理、保存、通知 - 做了太多事
      if self.validate(data):
          result = self.process(data)
          self.save(result)
          self.notify(result)
          return result
  
  # 遵循单一职责
  def validate(data):
      return self._validator.validate(data)
  
  def process(data):
      return self._processor.process(data)
  
  def save(data):
      self._repository.save(data)
  
  def notify(data):
      self._notifier.send(data)
  ```

### 4.2 开闭原则（Open/Closed Principle）
- **定义**：对扩展开放，对修改封闭
- **应用场景**：
  - 使用抽象基类
  - 定义接口
  - 使用依赖注入
- **示例**：
  ```python
  # 开闭设计
  class DatabaseManager:
      def __init__(self):
          self.connections = {}
      
      def create_connection(self, db_type, config):
          if db_type == "sqlite":
              return self._create_sqlite_connection(config)
          elif db_type == "mysql":
              return self._create_mysql_connection(config)
          else:
              raise ValueError(f"Unsupported database type: {db_type}")
  ```

### 4.3 依赖倒置原则（Dependency Inversion Principle）
- **定义**：依赖抽象而非具体实现
- **应用场景**：
  - 使用接口定义
  - 使用工厂模式创建对象
  - 通过构造函数注入依赖
- **示例**：
  ```python
  # 依赖倒置
  class UserService:
      def __init__(self, repository: UserRepository):
          self._repository = repository  # 依赖抽象
      
      def get_user(self, user_id: int):
          return self._repository.find_by_id(user_id)
  ```

### 4.4 接口隔离（Interface Segregation Principle）
- **定义**：客户端不应该依赖它不需要的接口
- **应用场景**：
  - 定义多个小接口
  - 客户端只依赖需要的接口
  - 使用适配器模式
- **示例**：
  ```python
  # 接口隔离
  class ReadOnlyRepository(Protocol):
      def find_by_id(self, id: int) -> Optional[User]:
          ...
  
  class ReadWriteRepository(ReadOnlyRepository, Protocol):
      def save(self, user: User) -> bool:
          ...
  
  # 客户端只依赖需要的接口
  class UserReader:
      def __init__(self, repository: ReadOnlyRepository):
          self._repository = repository
  ```

## 5. 代码可测试性

### 5.1 测试覆盖
- **单元测试**：核心逻辑必须有单元测试
- **集成测试**：主要流程必须有集成测试
- **覆盖率**：测试覆盖率不低于 80%
- **测试文件命名**：test_xxx.py

### 5.2 测试编写原则
- **AAA 模式**：Arrange、Act、Assert
- **测试独立性**：每个测试独立运行
- **Mock 外部依赖**：避免测试外部服务
- **测试可读性**：测试代码应该像文档一样清晰

### 5.3 测试示例
```python
import unittest
from unittest.mock import Mock, patch

class TestUserService(unittest.TestCase):
    def setUp(self):
        self.mock_repository = Mock()
        self.service = UserService(self.mock_repository)
    
    def test_get_user_success(self):
        # Arrange - 准备测试数据
        user_id = 1
        expected_user = User(id=1, name="Test User")
        self.mock_repository.find_by_id.return_value = expected_user
        
        # Act - 执行被测试的方法
        result = self.service.get_user(user_id)
        
        # Assert - 验证结果
        self.assertEqual(result, expected_user)
        self.mock_repository.find_by_id.assert_called_once_with(user_id)
    
    def test_get_user_not_found(self):
        # Arrange
        user_id = 999
        self.mock_repository.find_by_id.return_value = None
        
        # Act
        result = self.service.get_user(user_id)
        
        # Assert
        self.assertIsNone(result)
        self.mock_repository.find_by_id.assert_called_once_with(user_id)
```

## 6. 代码性能标准

### 6.1 性能指标
- **响应时间**：API 响应时间不超过 200ms
- **内存使用**：避免内存泄漏
- **数据库查询**：避免 N+1 查询问题
- **并发处理**：正确使用锁和线程安全

### 6.2 性能优化原则
- **避免过早优化**：先保证正确性，再优化性能
- **使用缓存**：合理使用缓存减少重复计算
- **批量操作**：数据库操作使用批量插入/更新
- **异步处理**：IO 密集型操作使用异步

## 7. 代码安全标准

### 7.1 输入验证
- **所有输入必须验证**：不接受未经验证的数据
- **白名单验证**：只允许预期的值
- **长度和格式检查**：验证输入长度和格式
- **SQL 注入防护**：使用参数化查询

### 7.2 敏感数据处理
- **不记录敏感信息**：密码、token 等不记录到日志
- **加密存储**：敏感数据必须加密存储
- **安全传输**：使用 HTTPS 传输敏感数据
- **最小权限原则**：只授予必要的权限

## 8. 代码质量检查工具

### 8.1 静态分析工具
- **pylint**：代码风格和错误检查
  ```bash
  pip install pylint
  pylint your_module.py --rcfile=.pylintrc
  ```
  
- **flake8**：PEP 8 合规性检查
  ```bash
  pip install flake8
  flake8 your_module.py
  ```
  
- **mypy**：静态类型检查
  ```bash
  pip install mypy
  mypy your_module.py --strict
  ```
  
- **black**：代码格式化
  ```bash
  pip install black
  black your_module.py
  ```

### 8.2 复杂度分析工具
- **radon**：代码复杂度分析
  ```bash
  pip install radon
  radon cc your_module.py -a
  ```
  
- **vulture**：未使用代码检测
  ```bash
  pip install vulture
  vulture your_module.py
  ```

### 8.3 代码质量评分
- **评分标准**：
  - A（90-100分）：优秀
  - B（80-89分）：良好
  - C（70-79分）：及格
  - D（60-69分）：需改进
  - E（0-59分）：不及格
  
- **评分工具**：
  ```bash
  pip install codeclimate
  codeclimate analyze your_module.py
  ```

## 9. 持续改进

### 9.1 代码审查流程
- **Pull Request 审查**：至少一人审查
- **自动化检查**：CI/CD 中集成代码质量检查
- **定期回顾**：定期回顾代码质量问题

### 9.2 技术债务管理
- **记录技术债务**：使用 issue 追踪已知问题
- **优先级管理**：按严重程度和影响范围排序
- **定期清理**：定期清理技术债务

### 9.3 知识分享
- **团队分享**：定期分享重构经验和最佳实践
- **文档更新**：及时更新文档和示例
- **培训学习**：定期进行代码质量培训

## 10. 参考资源

### 10.1 官方文档
- [PEP 8 - Style Guide for Python Code](https://peps.python.org/pep-0008/)
- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)
- [Clean Code by Robert C. Martin](https://www.amazon.com/Clean-Code-Handbook-Principles-Patterns-Practices/dp/0132019171)

### 10.2 重构参考
- [Refactoring Guru](https://refactoring.guru/)
- [Martin Fowler's Refactoring Catalog](https://refactoring.com/catalog/)
- [Working Effectively with Legacy Code](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0132019170)

### 10.3 最佳实践
- [The Pragmatic Programmer](https://www.amazon.com/Pragmatic-Programmer-Journey-Mastery/dp/0132019170)
- [Code Complete](https://www.amazon.com/Code-Complete-Practical-Handbook/dp/0132019170)
- [Growing Object-Oriented Software](https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Practices/dp/0132019170)